{StudioMix XFCN as part of                                        External Function for HyperCard 2.0+  }{  THE                                                                                                  }{    DIGITAL                                                                                            }{    SOUND STUDIO version 2.00                                                     (c)1996 Matt DeFano  }{                                                                                                       }{StudioMix is a custom XFCN written for the Digital Sound Studio Professional.                          }{The XFCN is passed a variable number of parameters to allow HyperCard to mix multiple sounds,          }{change pitch, volume, allow controls for pausing, stopping and flushing sound memory.  In addition     }{StudioMix is capable of returning sound resource info, CPU data and change system snd variables        }{StudioMix runs Asyncronusly in interupt mode allowing the user to continue all   actions and           }{work even while long sound samples are being played. The StudioMix allows sampling up to 44khz         }{and is compatible with the Macintosh Sound Manager 3.0+ and older versions.                            }{More information about StudioMix is availible in the Digial Sound Studio Pro package.                  }{                                                                                                       }{  NOTES AND CONVENTIONS:                                                                               }{      *   IT IS NOT ACCEPTABLE to call dispose() after RemoveRes -- RemoveRes disposes                 }{        the handle itself, calling dispose() will damage the master pointer list!!                     }{      *  HC = Hypercard 2.1                                                                            }{      *  sndMgr = the Macintosh Sound Manager                                                          }{      *  Procedures starting with "Studio" (ie StudioPlay) are called directly from MAIN, all          }{        others are utility routines.                                                                   }{      *  Due to build requirements, (gPascalVar = 'AnyString' ), will crash, therfore, the HC          }{        callback proc stringEqual is used instead.                                                     }{                                                                                                       }{  StudioMix Syntax is as follows:                                                                      }{                                                                                                       }{        StudioMix(SUBCMD,[Channel],[param1],[param2],[param3])                                         }{                                                                                                       }{      Example:                                                                                         }{        Get StudioMix(Play,Chan1,kSoundResID,kInitVol,kInitRate)                                       }{                                                                                                       }{    The following is StudioMix's Build (in order):                                                     }{                                                                                                       }{      Interface.lib      Contains Pascal Commands/Procs & Built-in Mac Toolbox routines                }{      HyperXLib.Lib      Countains HyperCard XCMD/XFCN Memory data                                     }{      Sound.p            Countains Toolbox routines discussed in Inside Macintosh Sound                }{      HyperXCmd.p        HyperXCmd Contains jump code and HyperCard Callback procs                     }{      FixMath            Provides Toolbox Traps for Fixed point math (used in rate procedures)         }{      StudioMix.p        Main XFCN Code and Entrypoint                                                 }{Unit is StudioMix (Must be same as command name in MPW)}unit StudioMix;interface  uses    Sound, HyperXCmd, FixMath, SoundInput, SysEqu;{Interface Main for entrypoint from HyperCard}  procedure Main (ParamPtr: XCmdPtr);implementation{procedure to pass StudioMix errors back to HyperCard}  procedure PassError (ParamPtr: XcmdPtr; ErrNum: Integer);    const      Err700 = '(-700) "Bad Parameter List."';                                       {user passed wrong number of params}      Err701 = '(-701) "Not Enough Memory."';                                        {not enough mem to load snd}      Err702 = '(-702) "Invalid or Bad Sound (''snd '') Resource"';                  {snd doesnt exist}      Err703 = '(-703) "Bad Parameter In Command"';                                  {bad subcommand param}      Err704 = '(-704) "Digital Sound Studio General Failure"';                      {multiple internal XFCN failure (bad news)}      Err705 = '(-705) "Error Sending Sound Manager Command"';                       {Couldnt send the SndMgr the processed cmd}      Err706 = '(-706) "Can''t unload a resource in use"';                           {User tried to unload a busy sndHandle}      Err707 = '(-707) "Couldn''t find a resource with that name"';                  {No resource found}      Err709 = '(-709) "There is currently no sound resource cued in that channel"'; {Cant play cue}      Err711 = '(-709) "Cued Sounds cannot be played from disk"';                    {Cant play cue from disk}      Err712 = '(-712) "DiskPlay must be set to ''ON'' or ''OFF'' "';                {Cant set DiskPlay param}      Err713 = '(-713) "PlayThru must be set to ''TRUE'' or ''FALSE'' "';            {Cant set PlayThru param}      Err714 = '(-714) "Not enough availible memory to load the variation."';        {Cant Load Variation}      Err715 = '(-715) "There is not enough memory to continue playing the beat"';   {Cant Continue}    var      ReturnHandle: Handle;    {Handle to pass string back to HyperCard}  begin    if (ErrNum > 715) or (ErrNum < 700) then    {convert a bad error}      ErrNum := 704;    case ErrNum of      700:        ReturnHandle := PasToZero(ParamPtr, Err700);      {assign the converted error codes to ReturnHandle}      701:        ReturnHandle := PasToZero(ParamPtr, Err701);      702:        ReturnHandle := PasToZero(ParamPtr, Err702);      703:        ReturnHandle := PasToZero(ParamPtr, Err703);      704:        ReturnHandle := PasToZero(ParamPtr, Err704);      705:        ReturnHandle := PasToZero(ParamPtr, Err705);      706:        ReturnHandle := PasToZero(ParamPtr, Err706);      707:        ReturnHandle := PasToZero(ParamPtr, Err707);      709:        ReturnHandle := PasToZero(ParamPtr, Err709);      711:        ReturnHandle := PasToZero(ParamPtr, Err711);      712:        ReturnHandle := PasToZero(ParamPtr, Err712);      713:        ReturnHandle := PasToZero(ParamPtr, Err713);      714:        ReturnHandle := PasToZero(ParamPtr, Err714);      715:        ReturnHandle := PasToZero(ParamPtr, Err715);    end;    ParamPtr^.ReturnValue := ReturnHandle;    {Pass the error string as the ReturnVal}  end;  procedure SaveVuAdr (ParamPtr: XcmdPtr; VURef: LongInt);    const      kVUvar = 'DSSLevelDriver';    var      HyperVarHndl: Handle;      HyperVarStr: Str255;  begin    LongToStr(ParamPtr, VURef, HyperVarStr);            {convert it to a Str255}    HyperVarHndl := PasToZero(ParamPtr, HyperVarStr);   {convert Str to a handle}    SetGlobal(ParamPtr, kVUvar, HyperVarHndl);          {Save the channel}  end;  function GetVUAdr (ParamPtr: XcmdPtr): LongInt;    const      kVUvar = 'DSSLevelDriver';    var      HyperVarHndl: Handle;      HyperVarStr: Str255;  begin    HyperVarHndl := GetGlobal(paramPtr, kVUvar);                  {Get the HyperCard Data}    ZeroToPas(ParamPtr, POINTER(HyperVarHndl^), HyperVarStr);     {Convert Zero-Term to Pascal str}    GetVUAdr := StrToLong(paramPtr, HyperVarStr);                 {Convert Str to LongInt}  end;{procedure to turn the recording playthrough on or off}  procedure Playthrough (IsOn: Boolean; ParamPtr: XcmdPtr);    var      InRefNum: LongInt;    {ref number for SoundInput routines}      InfoErr: OsErr;        {Errors returned getting info}      Amplitude: integer;    {Amplitude of playthrough}  begin    if IsOn then          {set playthrough volume}      Amplitude := 7    else      Amplitude := 0;    InfoErr := SPBOpenDevice('', siWritePermission, InRefNum);                {open the soundIn driver}    infoErr := SPBSetDeviceinfo(InRefNum, siplaythruOnOff, Ptr(@Amplitude));  {set the playthrough driver}    if not IsOn then      InfoErr := SPBCloseDevice(InRefNum);                                    {close the driver}  end;  {procedure}{Function to create a new sndMgr sound channel}  function CreateSndChannel (Synth: Integer; Initoptions: LongInt; QueueLength: Integer): SndChannelPtr;    var      DSSSndChan: SndChannelPtr;      {a pointer to the sndChannel record}      DSSErr: OsErr;                {Any OS errors}  begin    InitOptions := initNoInterp + initStereo;    DSSSndChan := SndChannelPtr(NewPtr(SizeOf(sndChannel)));          {allocate a new SndChannelPtr}    if DSSSndChan <> nil then      begin        DSSSndChan^.qLength := QueueLength;                           {set sound manager QueueLength }        DSSErr := SndNewChannel(DSSSndChan, Synth, InitOptions, nil); {Create the channel}        if DSSErr <> NoErr then                                       {determine any errors}          begin            DSSSndChan := nil;        {assign a nil pointer to the fuctionif it fails}            DisposePtr(ptr(DSSSndChan));          end {end if}        else          DSSSndChan^.UserInfo := 0;    {Reset userInfo field}      end; {end else}    CreateSndChannel := DSSSndChan;     {pass the DSSSndChannel}  end; {end Function}{Procedure to install old channels ( POINTER locations stored in HyperCard Global Variables)  }  procedure InstallOldChannels (ParamPtr: XcmdPtr; var Chan1Ptr, Chan2Ptr, BeatPtr: SndChannelPtr);{Local function to install individual channel}    function InstallThisChan (ParamPtr: XCmdPtr; TheVarLoc: Str255): SndChannelPtr;      const        SampledSynth = 5;          {allow only sampled sounds to be played on this channel}        NoInitOptions = 16;        StandardQLength = 128;     {Install a 128cmd queue}      var        ChanLocInt: LongInt;          {pointer location to the channel}        HyperVarHndl: Handle;        {HyperCard Global Variable Zero terminated handle}        HyperVarStr: Str255;        {HyperCard Global Variable string}    begin      HyperVarHndl := GetGlobal(paramPtr, TheVarLoc);              {Get the HyperCard Data}      if HyperVarHndl = nil then        begin          InstallThisChan := nil;          exit(InstallThisChan);        end;      ZeroToPas(ParamPtr, POINTER(HyperVarHndl^), HyperVarStr);    {Convert Zero-Term to Pascal str}      ChanLocInt := StrToLong(paramPtr, HyperVarStr);              {Convert Str to LongInt}      if ChanLocInt < 1 then      {If channel was not saved then}        InstallThisChan := CreateSndChannel(SampledSynth, NoInitOptions, 200)    {create a new channel}      else        InstallThisChan := POINTER(ORD4(ChanLocInt));    {Install the chan per the LongInt Data}      DisposeHandle(HyperVarHndl);    {dispose the string handle}    end;  {end InstallThisChan}    const      ChanAVar = 'DSSInternalData1';       {HyperCard Global variable names for channel ptr location data}      ChanBVar = 'DSSInternalData2';      BeatChanVar = 'DSSInternalData0';  begin    Chan1Ptr := InstallThisChan(ParamPtr, ChanAVar);      {Install the channel A ("ChanA") Sndchannel}    Chan2Ptr := InstallThisChan(ParamPtr, ChanBVar);      {Install the channel B ("ChanB") Sndchannel}    BeatPtr := InstallThisChan(ParamPtr, BeatChanVar);    {Install the background loop ("BEAT") Sndchannel}  end; {endInstallOldChannels}{Proc to save a previously loaded or newly created SndChannel in HyperCard}  procedure SaveDSSChannels (ParamPtr: XCmdPtr; ChanA, ChanB, BeatChan: SndChannelPtr);    const    {HyperCard global variable string names}      ChanAVar = 'DSSInternalData1';    {name of variable to hold "ChanA" pointer location}      ChanBVar = 'DSSInternalData2';    {name of variable to hold "ChanB" pointer location}      BeatChanVar = 'DSSInternalData0'; {name of variable to hold "BEAT" pointer location}    var      ChanLocInt: LongInt;     {Location of channel ptr}      HyperVarHndl: Handle;    {Handle to a hyperCard variable}      HyperVarStr: Str255;     {String name of a HC global variable}  begin    ChanLocInt := ORD4(POINTER(ChanA));                  {Calc the Pointers LongInt Location}    LongToStr(ParamPtr, ChanLocInt, HyperVarStr);        {convert it to a Str255}    HyperVarHndl := PasToZero(ParamPtr, HyperVarStr);    {convert Str to a handle}    SetGlobal(ParamPtr, ChanAVar, HyperVarHndl);         {Save the channel}    ChanLocInt := ORD4(POINTER(ChanB));                  {Calc the Pointers LongInt Location}    LongToStr(ParamPtr, ChanLocInt, HyperVarStr);        {convert it to a Str255}    HyperVarHndl := PasToZero(ParamPtr, HyperVarStr);    {convert Str to a handle}    SetGlobal(ParamPtr, ChanBVar, HyperVarHndl);         {Save the channel}    ChanLocInt := ORD4(POINTER(BeatChan));                {Calc the Pointers LongInt Location}    LongToStr(ParamPtr, ChanLocInt, HyperVarStr);         {convert it to a Str255}    HyperVarHndl := PasToZero(ParamPtr, HyperVarStr);     {convert Str to a handle}    SetGlobal(ParamPtr, BeatChanVar, HyperVarHndl);       {Save the channel}    disposeHandle(HyperVarHndl);  end;  {end If}{Function to determine which channel was passed to XCMD, WITHOUT allocating unneeded channel memory}  function GetWantedChannel (ParamPtr: XcmdPtr; ChanParam: Integer): SndChannelPtr;    var      DSSchan1: SndChannelPtr;    {Channel 1 pointer}      DSSchan2: SndChannelPtr;    {Channel 2 pointer}      BeatChan: SndChannelPtr;    {Beat channel pointer}      ParamStr: Str255;           {Hypercard Channel parameter string}  begin    InstallOldChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);    {Get saved sound channels}    ZeroToPas(ParamPtr, ParamPtr^.params[ChanParam]^, ParamStr);  {convert the parameter handle to a str}    if StringEqual(paramPtr, ParamStr, 'Chan1') then              {If the channel param is "Chan 1" then}      GetWantedChannel := DSSChan1;                               {pass chan 1 back}    if StringEqual(paramPtr, ParamStr, 'Chan2') then      GetWantedChannel := DSSChan2;    if StringEqual(paramPtr, ParamStr, 'Beat') then      GetWantedChannel := BeatChan;    SaveDSSChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);      {resave the channels}  end;{Procedure to reinstall a saved snd handle from a passed sndChannelPtr}  function ReinstallSndHandle (ParamPtr: XcmdPtr; SndChannel: SndChannelPtr): Handle;    var      ResSndHandle: Handle;    {Handle to a sndHandle saved in the UserInfo field by the SaveSndHandle proc}  begin    if SndChannel^.userInfo <> 0 then      begin        ResSndHandle := (HANDLE(LONGINT(SndChannel^.userInfo)));      {rebuild the handle from the longInteger}        if ResSndHandle = nil then          begin            ReinstallSndHandle := nil;            exit(ReinstallSndHandle);          end;        HLockHi(ResSndHandle);                 {lock the handle}        ReinstallSndHandle := ResSndHandle;    {pass the sound handle}      end    else      ReinstallSndHandle := nil;  end;    {end ReinstallSndHandle}{Procedure to save the loc of the sndHandle in the UserInfo field of the applicable snd channel}  procedure SaveSndHandle (ParamPtr: XcmdPtr; SndHandle: Handle; SndChannel: SndChannelPtr);  begin    if SndChannel = nil then      exit(SaveSndHandle);    if SndHandle = nil then      begin        sndChannel^.userInfo := 0;        exit(saveSndHandle);      end;    HLockHi(SndHandle);      {Lock the sndHndl before writing its Loc, if it changes before next StudioMix call, the hndl dangles}    SndChannel^.userInfo := LONGINT(SndHandle);    {Save the handle loc in the userInfo field of the applicable sndChannel}  end;{Procedure to save the handle of the sound used as a variant in HndlVarLoc}  procedure SaveVariantHandle (ParamPtr: XcmdPtr; VarHandle: Handle);    const      HndlVarLoc = 'DSSVariantData';        {Name of HC Global var to save in}    var      HandleLocInt: LongInt;    {Pointer location}      HyperVarStr: Str255;    {Variable string}      HyperVarHndl: Handle;    {Handle to the string}  begin    if VarHandle = nil then      begin        HyperVarHndl := PasToZero(ParamPtr, '0');       {convert Str to a handle}        SetGlobal(ParamPtr, HndlVarLoc, HyperVarHndl);  {Save the channel}      end;    hLockHi(VarHandle);    HandleLocInt := LongInt(HANDLE(VarHandle));         {Calc the handles LongInt Location}    LongToStr(ParamPtr, HandleLocInt, HyperVarStr);     {convert it to a Str255}    HyperVarHndl := PasToZero(ParamPtr, HyperVarStr);   {convert Str to a handle}    SetGlobal(ParamPtr, HndlVarLoc, HyperVarHndl);      {Save the channel}    disposeHandle(HyperVarHndl);  end;{Function to retrieve the last used variant handle}  function GetOldVariant (ParamPtr: XcmdPtr): Handle;    const      HndlVarLoc = 'DSSVariantData';    var      HandleLocInt: LongInt;      {locked location to handle}      HyperVarStr: Str255;      {Parameter string}      HyperVarHndl: Handle;      {A handle to the string}      TempHandle: Handle;  begin    HyperVarHndl := GetGlobal(paramPtr, HndlVarLoc);              {Get the HyperCard Data}    if HyperVarHndl = nil then      begin        GetOldVariant := nil;        exit(GetOldVariant);      end;    ZeroToPas(ParamPtr, POINTER(HyperVarHndl^), HyperVarStr);     {Convert Zero-Term to Pascal str}    HandleLocInt := StrToLong(paramPtr, HyperVarStr);             {Convert Str to LongInt}    if HandleLocInt <> 0 then      TempHandle := HANDLE(LongInt(HandleLocInt));                {Install the chan per the LongInt Data}    hLockHi(TempHandle);    GetOldVariant := TempHandle;    disposeHandle(HyperVarHndl);  end;{Function replacing SndMgr v 3.0 routine "GetSoundHeaderOffset"}  function DSSGetSoundHeaderOffset (SndHdl: Handle; var Offset: LongInt): OsErr;    type      Snd1Header = record          {Record for stand. snd headers}          Format: Integer;         {format type (either 1 or 2)}          NumSynths: Integer;      {Synasizer format}        end;  {End Record}      Snd1HdrPtr = ^Snd1Header;    {A pointer to the record}      Snd2Header = record          {Record for HyperCard snd headers}          Format: Integer;         {format type (either 1 or 2)}          RefCount: Integer;       {Reference count (similar to NumSynths execpt in HC Snd formats}        end;  {End record}      Snd2HdrPtr = ^Snd2Header;    {A pointer to the Snd2 record}      IntPtr = ^Integer;           {A pointer to an integer}      SndCmdPtr = ^SndCommand;     {A pointer to a soundCommand}    var      DSSPtr: Ptr;                 {Pointer of sndHeader data}      DSSOffset: LongInt;          {Offset length}      NumSynths: Integer;          {Synth number}      NumCmds: integer;            {Number of cmds in the Sound reource}      isDone: Boolean;             {Boolean var to flag that the function has parsed all commands}      DSSErr: OsErr;               {Any OS errors}  begin    hLockhi(SndHdl);    if SndHdl = nil then      begin        exit(DSSGetSoundHeaderOffset);      end;    DSSOffset := 0;          {reset the offset}    DSSPtr := PTR(sndHdl^);  {assign the DSSPtr to a sndHandle}    IsDone := False;         {Assume the first command is not the sndHandle}    DSSErr := NoErr;         {Reset the err}    case snd1HdrPtr(DSSPtr)^.format of      FirstSoundFormat:        begin          NumSynths := Snd1HdrPtr(DSSPtr)^.numSynths;            {Get synthasizer options}          DSSPtr := PTR(ORD4(DSSPtr) + SizeOf(Snd1Header));      {get header bytes}          DSSPtr := PTR(ORD(DSSPtr) + NumSynths * (SizeOf(INTEGER) + SizeOf(LongInt)));  {find data offset}        end;  {End Case}      SecondSoundFormat:        DSSPtr := PTR(ORD4(DSSPtr) + Sizeof(Snd2Header));     {determine the given length of the HC (type2) snd resource}      otherwise    {if the resource doesnt fit the snd resource lengths}        begin          DSSErr := BadFormat;    {Pass a BadFormat err}          IsDone := TRUE;         {loop is done}        end;  {End Case Otherwise}    end;    NumCmds := IntPtr(DSSPtr)^;    {Get the number of cmds in the resource}    DSSPtr := PTR(ORD4(DSSPtr) + SizeOf(Integer));    while (NumCmds >= 1) and (not isDone) do          {Parse through the Resource data}      begin{Determine if the command is a bufferCmd}        if (IntPtr(DSSPtr)^ = BufferCmd + DataOffsetFlag) or (IntPtr(DSSPtr)^ = SoundCmd + DataOffsetFlag) then          begin            DSSOffset := SndCmdPtr(DSSPtr)^.param2;  {if cmd is BufferCmd then pass the cmds offset}            IsDone := TRUE;  {We've found the snd Data!}          end  {End if}        else          begin            DSSPtr := Ptr(ORD4(DSSPtr) + SizeOf(SndCommand)); {Otherwise move the pointer to the next command}            NumCmds := NumCmds - 1;    {reindex the total num of cmds left to check}          end;  {End else}      end; {end While}    OffSet := DSSOffset;      {Pass the found offset as the function variable}    DSSGetSoundHeaderOffset := DSSErr;  {Return any function errors}  end; {end DSSGetSoundHeaderOffset}  function DoCheckMoreMem (ParamPtr: XcmdPtr; Chan: SndChannelPtr): Boolean;    var      Chan1, Chan2, BeatChan, CheckChan: SndChannelPtr;      theStatus: SCStatusPtr;      StatusErr: OSErr;      OldHandle: Handle;  begin    InstallOldChannels(ParamPtr, Chan1, Chan2, BeatChan);    if Chan = Chan1 then      CheckChan := Chan2;    if Chan = Chan2 then      CheckChan := Chan1    else      begin        SaveDSSChannels(ParamPtr, Chan1, Chan2, BeatChan);        DoCheckMoreMem := false;        Exit(DoCheckMoreMem);      end;    TheStatus := SCStatusPtr(NewPtr(SizeOf(SCStatus)));    {get memory for the pointer}    StatusErr := SndChannelStatus(CheckChan, SizeOf(SCStatus), TheStatus);  {get status}    if not (TheStatus^.SCChannelBusy) then      begin        OldHandle := reinstallSndHandle(ParamPtr, CheckChan);        if OldHandle <> nil then          begin            releaseResource(OldHandle);            OldHandle := nil;          end;        SaveSndHandle(ParamPtr, OldHandle, CheckChan);        DoCheckMoreMem := true;      end;    SaveDSSChannels(ParamPtr, Chan1, Chan2, BeatChan);  end;{Low level sound-sample routine  (compatable only with 'snd ' 1 & 2 format sounds)  will play all sample rates and}{any compressed sndHeaders}  function DSSPlaySampledSound (Chan: SndChannelPtr; SampleName: Str255; Loop: Boolean; ParamPtr: XcmdPtr): OsErr;    const      StdQLenght = 128;    {standard queue length is 128 commands}    var      DSSOffSet: LongInt;            {the offset in bytes from the beginning of the resource}      DSSSndCmd: SndCommand;         {A pointer to the play soundMgr command}      DSSErr: OsErr;                 {any errors encountered}      SndHandle, OldHandle: Handle;  {Sound data handles}      LoopInt: LongInt;              {a beat loop index}  begin    OldHandle := nil;    OldHandle := ReinstallSndHandle(ParamPtr, Chan);        {rereference the handle}    if not StringEqual(ParamPtr, SampleName, 'Cue') then    {Check if snd to play is not the cue}      begin        if (OldHandle <> nil) then       {determine that  the handle is not bad and does exist}          ReleaseResource(OldHandle);    {release its memory}        SndHandle := GetNamedResource('snd ', SampleName);  {Refrence the handle with the resource data}      end    else    {otherwise, play the cued sound}      begin        SndHandle := ReinstallSndHandle(ParamPtr, Chan);    {get the handle back from the UserInfo}        if (SndHandle = nil) then          begin            PassError(ParamPtr, 709);            exit(DSSPlaySampledSound);          end;      end;    if (SndHandle <> nil) then   {assuming no errors occured}      begin        HLockHi(SndHandle);      {lock the handle high so the memMgr doesnt move it during play}        DSSErr := DSSGetSoundHeaderOffset(SndHandle, DSSOffset);      {Find the sndHandles sample offset}        if DSSErr = NoErr then   {be sure the data was valid and an offset was calculated}          begin            with DSSSndCmd do              begin                DSSSndCmd.Cmd := flushCmd;      {cmd is BufferCmd}                DSSSndCmd.Param1 := 0;                DSSSndCmd.Param2 := 0;              end; {end with}            DSSErr := SndDoImmediate(Chan, DSSSndCmd);        {send bufferCmd in front of Channel Queue}            with DSSSndCmd do              begin                DSSSndCmd.Cmd := BufferCmd;      {cmd is BufferCmd}                DSSSndCmd.Param1 := 0;          {unused Parameter with bufferCmd}                DSSSndCmd.Param2 := LONGINT(ORD4(SndHandle^) + DSSOffset);    {Pass the data offset to BufferCmd}              end; {end with}            if Loop = FALSE then              begin                DSSErr := SndDoCommand(Chan, DSSSndCmd, false);        {send bufferCmd in front of Channel Queue}              end            else if Loop = TRUE then      {If snd play a Beat then...}              begin                for loopInt := 1 to 50 do      {Loop the sndDoCommand command to place the cmd in the queue approx 108 times}                  begin                    DSSErr := SndDoCommand(Chan, DSSSndCmd, false);      {Place the bufferCmd in the channel queue}                    if (DSSErr <> NoErr) or (MemError <> noErr) then                      exit(DSSPlaySampledSound);                  end;              end;          end; {end if}        DSSPlaySampledSound := DSSErr;                {passBack any errors}        SaveSndHandle(ParamPtr, SndHandle, Chan);     {Save the SndHandle Location in a HyperCard global var}      end  {end good sndHandle}    else    {Bad handle}      begin        if ResError = resNotFound then          PassError(ParamPtr, 707)      {Return a "couldnt find res err"}        else          PassError(ParamPtr, 701);     {Return a "not enough memory" error}      end;  end;{Proc to resume originaly stored rate by SaveRate}  procedure ResumeNormalRate (ParamPtr: XcmdPtr; TheChan: SndChannelPtr);    var      TheCommand: SndCommand;      RateErr: OsErr;    const      rate22khz = 1;                      {22khz RateCmd const in LongInt form}      ChanRateInt = rate22Khz;            {reset to default 22khz}  begin    if TheChan <> nil then                {is Good Chan?}      begin        with TheCommand do          begin            cmd := RateCmd;               {cmd is RateCmd}            Param1 := 0;                  {Param1 is unused}            Param2 := FIXED(ChanRateInt);    {reset to fixed int ChanRateInt}          end;  {end with}        RateErr := SndDoImmediate(GetWantedChannel(ParamPtr, 2), TheCommand);          {pass the cmd to SndMgr}      end{end if}    else      PassError(ParamPtr, 704);      {pass error back to HC}  end; {end proc}{Function to determine if the number of params passed is ProperNumParams and pass err if not}  function ProperHyperParam (ParamPtr: XcmdPtr; ProperNumParams: Integer): Boolean;    const      kErrStr = '(-700) "Bad Parameter List."';  begin    if (ParamPtr^.ParamCount) <> (ProperNumParams) then          {get the Param count}      begin        ParamPtr^.ReturnValue := PasToZero(ParamPtr, kErrStr);   {Put the err in the RetunValue field}        ProperHyperParam := FALSE;      end    else      ProperHyperParam := TRUE;  end;{Procedure to Set the rate of currently playing sound}  procedure SetRate (ParamPtr: XcmdPtr; TheRate: Integer; TheChan: SndChannelPtr; DoNow: Boolean);    var      TheCommand: SndCommand;      {Sound command}      RateErr: OsErr;              {any errors}      SetRate: fixed;              {fixed int to rate}  begin    if TheRate > 10 then           {if badRate then reset it}      TheRate := 11;    if TheRate < 1 then      TheRate := 1;    case TheRate of                {install proper fixedInt values}{For information on setting Fixed Integer values for RateCmd see Inside Macinstosh Sound}      1:        SetRate := $00010000 - 4000;      2:        SetRate := $00010000 - 3000;      3:        SetRate := $00010000 - 2000;      4:        SetRate := $00010000 - 1000;      5:        SetRate := $00010000;      6:        SetRate := $00010500;      7:        SetRate := $00011000;      8:        SetRate := $00011500;      9:        SetRate := $00012000;      10:        SetRate := $00012500;      11:        SetRate := $00020000;      {this is for "Fast Play"}    end;    if TheChan <> nil then         {check for good Channel}      begin        with theCommand do          begin            Cmd := RateCmd;        {Cmd is RateCmd}            Param1 := 0;           {Unused with RateCmd}            Param2 := SetRate;     {Fixed integer relative to 22.25 khz}          end;  {end with}        if DoNow then                                     {Cmd must be sent now?}          RateErr := SndDoImmediate(TheChan, TheCommand)        else                                              {can wait in Chan's queue?}          RateErr := SndDoCommand(TheChan, TheCommand, FALSE);        if RateErr <> NoErr then          PassError(ParamPtr, 705);                       {Give err for bad snd Command}      end  {end if}    else      PassError(ParamPtr, 704);                           {Give err if Snd Channel was bad}  end; {End SetRate}{Procedure used to set playing snds volume (amplitude)}  procedure SetVol (ParamPtr: XcmdPtr; DSSChan: SndChannelPtr; VolumeLevel: Integer; DoNow: boolean);    const      kWaitIfFull = True;                {wait for room in queue}    var      TheCommand: SndCommand;            {the sound command}      SndVolErr: OSErr;                  {volume error}  begin    if VolumeLevel > 255 then            {compensate for bad level param}      VolumeLevel := 255;    if VolumeLevel < 0 then      VolumeLevel := 0;    with TheCommand do      begin        Cmd := ampCmd;            {cmd is AmpCmd}        Param1 := VolumeLevel;    {Param1 is Amplitude level}      end;  {end with}    if DoNow = False then                                          {need cmd passed now?}      SndVolErr := SndDoCommand(DSSChan, TheCommand, KWaitIfFull)  {Pass the command at end of queue}    else      SndVolErr := SndDoImmediate(DSSChan, TheCommand);            {Pass the command as immediate}    if SndVolErr <> NoErr then                                     {pass any errors}      PassError(ParamPtr, 705);                                    {Pass "Bad snd mgr command"}  end; {end proc}{Procedure to initiate a HyperCard soundPlay}  procedure StudioPlay (ParamPtr: XcmdPtr);    const      kParamCount = 5;              {proper num of cmds passed}      kNoInitOps = 3;      kDoImmediate = FALSE;      kNoLoop = FALSE;      kAdjustVol = 20;    var      ParamStr: Str255;      ResIDname: Str255;      SndErr: OsErr;      VolLevel: integer;      Pitch, TheAdjust: Integer;      DSSChan1, DSSChan2, BeatChan: SndChannelPtr;  begin    ZeroToPas(ParamPtr, ParamPtr^.params[3]^, ResIDName);        {Get 3rd param (snd Name)}    if ParamPtr^.ParamCount = kNoInitOps then      VolLevel := 255    else      begin        ZeroToPas(ParamPtr, ParamPtr^.params[4]^, ParamStr);     {Get 4th param (initial volume level)}        VolLevel := INTEGER(StrToLong(ParamPtr, ParamStr));      end;    SetVol(ParamPtr, GetWantedChannel(ParamPtr, 2), VolLevel, kDoImmediate);            {set the init volume to 4th param}    ZeroToPas(ParamPtr, ParamPtr^.params[5]^, ParamStr);         {Get Pitch from 5th param}    Pitch := INTEGER(StrToLong(ParamPtr, ParamStr));    SndErr := DSSPlaySampledSound(GetWantedChannel(ParamPtr, 2), ResIDName, kNoLoop, ParamPtr);  {finally play the snd}    if ParamPtr^.ParamCount = kParamCount then      SetRate(ParamPtr, Pitch, GetWantedChannel(ParamPtr, 2), True);                  {set the initial pitch}  end;  {end StudioPlay}{procedure to stop inPlay sound}  procedure StudioStop (ParamPtr: XcmdPtr);    const      KparamCount = 2;           {Proper num of HC Params}      kAddLev = 20;    var      ParamStr: str255;          {parameter string from HC}      TheCommand: SndCommand;    {The stop command}      SndErr: OSErr;             {SoundMgr errors}      SndHandle: Handle;         {Handle to the sound in play (in order to dispose)}  begin    if GetWantedChannel(ParamPtr, 2) <> nil then      begin        with TheCommand do          begin            cmd := QuietCmd;      {cmd is QuietCmd}            Param1 := 0;          {Param1 & Param2 are unused in QuietCmd}            Param2 := 0;          end;        SndErr := SndDoImmediate(GetWantedChannel(ParamPtr, 2), TheCommand);       {always pass quietCmd immediatly}        SndHandle := ReinstallSndHandle(ParamPtr, GetWantedChannel(ParamPtr, 2));  {get old snd handle}        if SndHandle <> nil then          ReleaseResource(SndHandle);    {kill the handle}        SaveSndHandle(ParamPtr, nil, GetWantedChannel(ParamPtr, 2));    {save the new "nil" handle}        if SndErr <> NoErr then          {pass SndMgr errs}          passError(ParamPtr, 705);      end  {end if}    else                                 {if bogus chan then pass GenFail Err}      passError(ParamPtr, 704);    SaveSndHandle(ParamPtr, nil, GetWantedChannel(ParamPtr, 2));  end; {end StudioStop}{Procedure to pause an InPlay sound}  procedure StudioPause (ParamPtr: XcmdPtr);    const      KparamCount = 2;           {number of parameters to follow}    var      ParamStr: str255;          {string to the channel parameter}      TheCommand: SndCommand;    {the pause command}      PauseErr: OsErr;           {any SndMgr errors}  begin    if GetWantedChannel(ParamPtr, 2) <> nil then      begin        with TheCommand do          begin            Cmd := RateCmd;      {cmd is rateCmd}            Param1 := 0;         {Unused}            Param2 := 0;         {Rate is 0 (rate of zero pauses the sound) }          end; {enf with}        PauseErr := SndDoImmediate(GetWantedChannel(ParamPtr, 2), TheCommand);    {Pass the cmd to SndMgr now}        if PauseErr <> NoErr then          PassError(ParamPtr, 705);    {Report any errors}      end;  end;  {end StusioPause}{Procedure to restart a paused sound from its paused location}  procedure StudioResume (ParamPtr: XcmdPtr);    const      KparamCount = 2;       {number of parameters to follow}    var      ParamStr: str255;      {string to the channel parameter}  begin    ResumeNormalRate(ParamPtr, GetWantedChannel(ParamPtr, 2));      {resume sound play}  end; {proc}{procedure to set the output volume of any currently playing sound}  procedure StudioVol (ParamPtr: XcmdPtr);    const      kParamCount = 3;    {Proper number of parameters}      kSetNow = TRUE;     {need to set vol now?}    var      TheVol: Integer;          {the sound volume}      ParamStr: Str255;         {Parameter string}      DSSChan1: SndChannelPtr;  {Sound channel pointers:}      DSSChan2: SndChannelPtr;      BeatChan: SndChannelPtr;  begin    if ProperHyperParam(paramPtr, kParamCount) then      {make sure enought params sent}      begin        InstallOldChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);    {get old channels}        ZeroToPas(ParamPtr, ParamPtr^.params[3]^, ParamStr);           {get new vol}        TheVol := INTEGER(StrToNum(ParamPtr, ParamStr));               {convert to integer}        ZeroToPas(ParamPtr, ParamPtr^.params[2]^, ParamStr);           {get the channel}        if TheVol < 0 then    {compensate for a negative volume}          TheVol := 0;        if (StringEqual(paramPtr, ParamStr, 'Chan1')) then             {use which channel?}          SetVol(ParamPtr, DSSChan1, TheVol, kSetNow)                  {pass the SetVol proc cmd}        else          SetVol(ParamPtr, DSSChan2, TheVol, kSetNow);                 {set the volume}        SaveDSSChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan)        {save the old chan locs}      end;  end;{Procedure to change a sounds playBack rate}  procedure StudioRate (ParamPtr: XcmdPtr);    const      kParamCount = 3;    {number of params to follow}      kDoNow = TRUE;      {Send command now?}    var      TheRate: Integer;   {integer to the new rate}      ParamStr: Str255;   {String to new rate}  begin    if ProperHyperParam(paramPtr, kParamCount) then      begin        ZeroToPas(ParamPtr, ParamPtr^.params[3]^, ParamStr);               {Get the rate param}        TheRate := StrToLong(ParamPtr, ParamStr);                          {convert to Int}        SetRate(ParamPtr, TheRate, GetWantedChannel(ParamPtr, 2), kDoNow); {send the RateProc cmd}      end;  {end if}  end;  {end StudioRate}{Proc to Flush all Digital Sound Studios Memory and Channel Locations}  procedure StudioFlush (ParamPtr: XcmdPtr);    const      kFlushedMem = '"Digital Sound Studio Global Memory Has Been Disposed"';      kBeatChanVar = 'DSSInternalData0';      kChanAVar = 'DSSInternalData1';      kChanBVar = 'DSSInternalData2';      kQuietNow = True;      resetInt = 0;    var      DSSChan1: SndChannelPtr;    {sound channel pointers}      DSSChan2: SndChannelPtr;      BeatChan: SndChannelPtr;      FlushErr: OsErr;            {sound command errors}      ReturnHandle: Handle;       {Handle to result}      HyperVarStr: Str255;        {string to variable result}      HyperVarHndl: Handle;       {handle to a string}      TempSndHandle: Handle;  begin    InstallOldChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);        {get old channel Locations}    TempSndHandle := newHandleClear(0);    TempSndHandle := nil;    TempSndHandle := GetOldVariant(ParamPtr);    if TempSndHandle <> nil then      releaseResource(TempSndHandle);    TempSndHandle := newHandleClear(0);    TempSndHandle := nil;    TempSndHandle := ReinstallSndHandle(ParamPtr, DSSChan1);    if TempSndHandle <> nil then      releaseResource(TempSndHandle);    TempSndHandle := newHandleClear(0);    TempSndHandle := nil;    TempSndHandle := ReinstallSndHandle(ParamPtr, DSSChan2);    if TempSndHandle <> nil then      releaseResource(TempSndHandle);    TempSndHandle := newHandleClear(0);    TempSndHandle := nil;    TempSndHandle := ReinstallSndHandle(ParamPtr, BeatChan);    if TempSndHandle <> nil then      releaseResource(TempSndHandle);    SaveSndHandle(ParamPtr, nil, DSSChan1);    {remove old sound memory from channels}    SaveSndHandle(ParamPtr, nil, DSSChan2);    SaveSndHandle(ParamPtr, nil, BeatChan);    FlushErr := SndDisposeChannel(DSSChan1, kQuietNow);    {Kill chan 1}    FlushErr := SndDisposeChannel(DSSChan2, kQuietNow);    {Kill chan 2}    FlushErr := SndDisposeChannel(BeatChan, kQuietNow);    {Kill beat channel}    LongToStr(ParamPtr, ResetInt, HyperVarStr);            {Convert longInt to a str255}    HyperVarHndl := PasToZero(ParamPtr, HyperVarStr);      {Convert str255 to a zero-term Handle}    SetGlobal(ParamPtr, kChanAVar, HyperVarHndl);          {set HyperCard chan 1 global as zero}    SetGlobal(ParamPtr, kChanBVar, HyperVarHndl);          {set HyperCard chan 2 global as zero}    SetGlobal(ParamPtr, kBeatChanVar, HyperVarHndl);       {set HyperCard BeatChan global as zero}    if FlushErr <> noErr then                              {pass any errors}      PassError(ParamPtr, 705)    else      begin        ReturnHandle := PasToZero(ParamPtr, kFlushedMem);  {convert GoodFlush String}        ParamPtr^.ReturnValue := ReturnHandle;             {pass the GoodFlush}      end; {end if}    DisposeHandle(HyperVarHndl);    SaveDSSChannels(ParamPtr, nil, nil, nil);              {get old channel Locations}  end; {end StudioFlush}  procedure DoBeatRefresh (ParamPtr: XcmdPtr; BeatChan: SndChannelPtr);    var      Beat: Handle;      BeatCmd: SndCommand;      DSSOffset: LongInt;      PlayErr: OSerr;      Index: LongInt;  begin    Beat := ReinstallSndHandle(ParamPtr, BeatChan);    if (Beat <> nil) then      begin        HlockHi(Beat);        PlayErr := DSSGetSoundHeaderOffset(Beat, DSSOffset);        {Find the sndHandles sample offset}        with BeatCmd do          begin            BeatCmd.Cmd := BufferCmd;      {cmd is BufferCmd}            BeatCmd.Param1 := 0;           {unused Parameter with bufferCmd}            BeatCmd.Param2 := LONGINT(Beat^) + DSSOffset;    {Pass the data offset to BufferCmd}          end; {end with}      end    else      passError(paramPtr, 714);    if (BeatChan = nil) or (Beat = nil) then      begin        exit(DoBeatRefresh);      end;    SaveSndHandle(ParamPtr, Beat, BeatChan);    index := 1;    repeat      index := index + 1;      PlayErr := SndDoCommand(BeatChan, BeatCmd, false);        {send bufferCmd in front of Channel Queue}    until Index > 49;  end;{Procedure to send a queue of identical snd commands to loop a given sndHandle}  procedure StudioLoop (ParamPtr: XCmdPtr);    const      kBeatChanVar = 'DSSInternalData0';      kLoopSnd = TRUE;    var      DSSChan1: SndChannelPtr;    {sound channel pointers}      DSSChan2: SndChannelPtr;      BeatChan: SndChannelPtr;      HyperVarHndl: Handle;       {handle to the value of a HC global}      HyperVarStr: Str255;        {string to value of HC global}      ParamStr: Str255;           {String to a parameter}      FlushErr: OsErr;            {sndMgr errors}      ResIDName: Str255;          {Resource name to loop}      BeatErr: OsErr;             {Error playing beat}      TheCommand: SndCommand;     {the command}      SndHandle, VariantHandle: Handle;    {sound handles regarding the beat}      sndMgrVer: numVersion;  begin    InstallOldChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);    {get old channels}    ZeroToPas(ParamPtr, ParamPtr^.params[2]^, ParamStr);    if (StringEqual(paramPtr, ParamStr, 'STOP')) then      begin        with TheCommand do          begin            cmd := flushCmd;      {Command is flushCmd}            Param1 := 0;        {Param1&2 are unused}            Param2 := 0;          end;        FlushErr := SndDoImmediate(BeatChan, TheCommand);      {Flush the channel cmd queue}        sndHandle := newHandleClear(0);        SndHandle := nil;        SndHandle := ReinstallSndHandle(ParamPtr, BeatChan);   {Get the last used resource}        if SndHandle <> nil then          ReleaseResource(SndHandle);    {Purge the sound resource}        if FlushErr <> NoErr then          PassError(ParamPtr, 705);      {pass error 705}        SaveSndHandle(ParamPtr, nil, BeatChan);                {save new sound handles}        variantHandle := newHandleClear(0);        variantHandle := nil;        VariantHandle := GetOldVariant(ParamPtr);    {get last variant}        if VariantHandle <> nil then          ReleaseResource(VariantHandle);            {Kill the resource}        SaveDSSChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);      {save new channel data}      end    else if (StringEqual(paramPtr, ParamStr, 'DEVIATE')) then      {If the Subcmd is "DEVIATE" then}      begin        SndMgrVer := SndSoundManagerVersion;            {get sndMgr version}        if SndMgrVer.majorRev >= 3 then          begin            with TheCommand do              begin                cmd := flushCmd;      {Command is flushCmd}                Param1 := 0;          {Param1&2 are unused}                Param2 := 0;              end;            FlushErr := SndDoImmediate(BeatChan, TheCommand);    {Flush the channel cmd queue}          end;        with TheCommand do          begin            cmd := quietCmd;      {Command is QuietCmd}            Param1 := 0;          {Unused param1 & param2 with QuietCmd}            Param2 := 0;          end;        FlushErr := SndDoImmediate(BeatChan, TheCommand);  {Quiet the passed channel}        if SndMgrVer.majorRev >= 3 then          doBeatRefresh(ParamPtr, BeatChan);        if FlushErr <> NoErr then          PassError(ParamPtr, 705);      {If err then pass error (705)}      end    else   {otherwise  no subCmd is passed to BEAT then assume the2nd parameter is the resources' name}      begin        ZeroToPas(ParamPtr, ParamPtr^.params[2]^, ResIDName);                     {Convert the second parameter}        BeatErr := DSSPlaySampledSound(BeatChan, ResIDName, kLoopSnd, ParamPtr);  {Play the sound resource}        SndHandle := GetNamedResource('snd ', ResIDName);        SaveSndHandle(ParamPtr, SndHandle, BeatChan);      end;    SaveDSSChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);    {save the installed channels}  end;{Procedure to determine and return whether or not a snd Channel has finished processing}  procedure StudioDone (ParamPtr: XcmdPtr);    var      ParamStr: str255;        {string to channel parameter}      StatusErr: OsErr;        {any errors getting status}      TheStatus: SCStatusPtr;  {The status ptr}      IsSndDone: Boolean;      {has sound completed?}  begin    TheStatus := SCStatusPtr(NewPtr(SizeOf(SCStatus)));      {get memory for the pointer}    StatusErr := SndChannelStatus(GetWantedChannel(paramPtr, 2), SizeOf(SCStatus), TheStatus);  {get status}    IsSndDone := not (TheStatus^.SCChannelBusy);             {determine if sound is done}    BoolToStr(ParamPtr, IsSndDone, ParamStr);    ParamPtr^.ReturnValue := PasToZero(ParamPtr, ParamStr);  {assign the handle the string}    DisposePtr(Ptr(TheStatus));  end;{Procedure to return the offset of a passed snd resource}  procedure StudioOffset (ParamPtr: XcmdPtr);    var      SampleName: Str255;      {Name of the resource to be loaded}      OffsetErr: OsErr;        {An OS error}      Offset: LongInt;         {Sound headers offset}      SndHandle: Handle;       {Handle to hold resource data}      ReturnStr: Str255;       {String containing the return offset}  begin    ZeroToPas(ParamPtr, ParamPtr^.params[2]^, SampleName);           {Get the 2nd parameter (the resources name}    SndHandle := GetNamedResource('snd ', SampleName);               {load the resource}    if (SndHandle <> nil) and (ResError = NoErr) then      begin        OffsetErr := DSSGetSoundHeaderOffset(SndHandle, Offset);     {assign Offset the sndHandles samples offset}        if OffsetErr = NoErr then          begin            LongToStr(ParamPtr, Offset, ReturnStr);                  {convert the longInt to a string}            ParamPtr^.ReturnValue := PasToZero(ParamPtr, ReturnStr); {return the offset integer}          end        else          passError(ParamPtr, 704);    {Pass error (-704)}      end    else      passError(ParamPtr, 704);        {Pass error (-704)}  end;{Procedure to unload a loaded snd resource whose location is stored in a given DSSChannel parameter}  procedure StudioUnload (ParamPtr: XcmdPtr);    var      DSSChan1: SndChannelPtr;    {Pointer to the Chan1 record}      DSSChan2: SndChannelPtr;    {Pointer to the Chan2 record}      BeatChan: SndChannelPtr;    {Pointer to the beatChan record}      ChanInUse: SndChannelPtr;   {Channel to be processed}      ParamStr: Str255;           {String containing a XFCN parameter}      TheStatus: SCStatusPtr;     {A pointer to a sndChannel status record}      StatusErr: OSErr;           {Contains any OS errors}      SndHandle: Handle;          {Handle to hold sound samples}  begin    ZeroToPas(ParamPtr, ParamPtr^.params[2]^, ParamStr);           {Convert StudioMix param2 to a Str255}    InstallOldChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);    {install old channels}    StatusErr := SndChannelStatus(GetWantedChannel(ParamPtr, 2), SizeOf(SCStatus), TheStatus);  {Get the status record of ChanInUse}    if (TheStatus^.SCChannelBusy <> True) and (StatusErr = NoErr) then    {determine if safe to proceed on channel}      begin        if ChanInuse <> nil then          begin            SndHandle := ReinstallSndHandle(ParamPtr, GetWantedChannel(ParamPtr, 2));    {Get old sound handle}            if SndHandle <> nil then              begin                ReleaseResource(SndHandle);  {Release resource memory}              end;          end        else          PassError(ParamPtr, 703);  {Pass error (-703)}      end    else      PassError(ParamPtr, 706);      {Pass error (-706)}    SaveDSSChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);    SaveSndHandle(ParamPtr, SndHandle, GetWantedChannel(ParamPtr, 2));  end;{procedure to add a variation in the current beat}  procedure StudioVariate (ParamPtr: XcmdPtr);    const      kNoLoop = false;    var      SampleName: Str255;                             {name of variant sample}      DSSChan1, DSSChan2, BeatChan: SndChannelPtr;    {sound channels}      PlayErr: OsErr;                                 {Any play Errs}      SndHandle, BeatHandle, VariantHandle: Handle;   {Sound resource handles}      DSSsndCmd: SndCommand;                          {the sound command}      DSSOffset: LongInt;                             {Offset to samples}      Index: Integer;                                 {loop indexing}      TheStatus: SCStatusPtr;                         {Snd channel status}      StatusErr: OSErr;                               {Any status errs}  begin    InstallOldChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);    with DSSSndCmd do      begin        DSSSndCmd.Cmd := FlushCmd;      {cmd is Flush}        DSSSndCmd.Param1 := 0;          {unused Parameter with flushCmd}        DSSSndCmd.Param2 := 0;          {unused Parameter with flushCmd}      end; {end with}    PlayErr := SndDoImmediate(BeatChan, DSSSndCmd);        {send bufferCmd in front of Channel Queue}    variantHandle := newHandleClear(0);    VariantHandle := nil;    VariantHandle := GetOldVariant(ParamPtr);    if VariantHandle <> nil then      ReleaseResource(VariantHandle);    ZeroToPas(ParamPtr, ParamPtr^.params[2]^, SampleName); {Convert StudioMix param3 to a Str255}    sndHandle := newHandleClear(0);    sndHandle := nil;    SndHandle := GetNamedResource('snd ', SampleName);    if (SndHandle <> nil) then      begin        HlockHi(sndHandle);        PlayErr := DSSGetSoundHeaderOffset(SndHandle, DSSOffset);   {Find the sndHandles sample offset}        with DSSSndCmd do          begin            DSSSndCmd.Cmd := BufferCmd;      {cmd is BufferCmd}            DSSSndCmd.Param1 := 0;          {unused Parameter with bufferCmd}            DSSSndCmd.Param2 := LONGINT(ORD4(SndHandle^) + DSSOffset)          end; {end with}        PlayErr := SndDoCommand(BeatChan, DSSSndCmd, false);        {send bufferCmd in front of Channel Queue}      end    else      passError(paramPtr, 714);    DoBeatRefresh(ParamPtr, BeatChan);    SaveVariantHandle(ParamPtr, SndHandle);                         {save the variant sound handle}    SaveDSSChannels(ParamPtr, DSSChan1, DSSChan2, BeatChan);        {save channel locations}  end;{Procedue to cue a sound in a given sound channels UserInfo field}  procedure StudioCue (ParamPtr: XcmdPtr);    var      ParamStr: Str255;        {Paramter strings}      OldCueResource: Handle;    {Last resource cued}      CueResource: Handle;      {new resource to cue}      StatusErr: OSErr;          {any OS Errs}      TheStatus: SCStatusPtr;    {Status of the sound channel}  begin    StatusErr := SndChannelStatus(GetWantedChannel(paramPtr, 2), SizeOf(SCStatus), TheStatus);    if (TheStatus^.SCChannelBusy) then    {Determine if the channel to cue is busy}      PassError(ParamPtr, 708)        {If so, StudioMix cannot cue}    else      begin        OldCueResource := ReinstallSndHandle(ParamPtr, GetWantedChannel(ParamPtr, 2));    {get old res}        if OldCueResource <> nil then      {determine if res exists}          ReleaseResource(OldCueResource);        ZeroToPas(ParamPtr, ParamPtr^.params[3]^, ParamStr);        CueResource := (GetNamedResource('snd ', ParamStr));        HLock(CueResource);        SaveSndHandle(ParamPtr, CueResource, GetWantedChannel(ParamPtr, 2));    {Save the handle in userInfo}      end;  end;{Function to determine if the current operating environment can run studioMix}  function StudioGestalt: Boolean;    const      GestaltMultiChannels = 11;    {Bit selector}    var      response: LongInt;            {Gestalts response}      Result: Boolean;              {Gestalt result}      GestErr: OsErr;               {any OS Errs}      SndMgrVer: NumVersion;        {Snd Mgr version}  begin    Result := False;                                   {default the result}    SndMgrVer := SndSoundManagerVersion;               {get sndMgr version}    GestErr := Gestalt(GestaltSoundAttr, Response);    {Get gestalt value}    if SndMgrVer.majorRev >= 3 then      begin        if (GestErr = NoErr) and (BTst(Response, GestaltMultiChannels)) then   {Test the result}          Result := True;      end    else      begin        GestErr := Gestalt(GestaltHardwareAttr, Response);      {use alternate gestalt method for sndMgr < 3}        if (GestErr = noErr) and (bTst(Response, GestaltHasASC)) then          Result := True;      end;    StudioGestalt := Result;  end;{Procedure to set the Macintosh master volume level}  procedure StudioSetMaster (ParamPtr: XcmdPtr);    var      paramStr: str255;    {Parameter passed to studioMix (VolLevel)}      MasterVol: Integer;    {The volume}  begin    ZeroToPas(ParamPtr, ParamPtr^.params[2]^, ParamStr);     {get the volume Param value}    MasterVol := INTEGER(StrToNum(ParamPtr, ParamStr));      {Convert ParamStr to integer}    SetSoundVol(MasterVol);                                  {Set volume}  end;{Procedure to get the master output volume}  procedure StudioGetMaster (ParamPtr: XcmdPtr);    var      ReturnStr: str255;     {Master volume string returned to user}      MasterVol: Integer;    {volume level}  begin    GetSoundVol(MasterVol);                                   {get volume level}    NumToStr(ParamPtr, MasterVol, ReturnStr);                 {covert number to string}    ParamPtr^.ReturnValue := PasToZero(ParamPtr, ReturnStr);  {Pass back the volume}  end;    {end StudioGetMaster}{Procedure to return all current data regarding CPU load from the sound Mgr. Including Max Real Time avail, Real Time-}{Used,and number of allocated snd channels}  procedure StudioCPULoad (ParamPtr: XcmdPtr);    var      TheStatus: SMStatusPtr;    {Ptr to hold SndMgr status}      TheErr: OSerr;             {Any OS Errs}      LoadStr: Str255;           {Str to current CPU Load}      MaxStr: Str255;            {Str to max CPU load}      NumStr: Str255;            {Str to num of snd channels}      TheLoad: Integer;          {CPU Load}      MaxLoad: Integer;          {Max CPU Time}      NumChannels: Integer;      {number of channels}      returnStr: str255;         {Str to return as result of function}  begin    TheStatus := smStatusPtr(NewPtrClear(SizeOf(SMStatus)));      {Create a ptr to hold data}    TheErr := SndManagerStatus(SizeOf(SMStatus), TheStatus);      {Fill the ptr with SndMgr Status}    TheLoad := (TheStatus^.smCurCPULoad);                         {Get current CPU Load}    MaxLoad := (TheStatus^.smMaxCPULoad);                         {Get Max Load}    NumChannels := (TheStatus^.smNumChannels);                    {Get number of channels}    LongToStr(ParamPtr, TheLoad, LoadStr);                        {Convert values to strings}    LongToStr(ParamPtr, MaxLoad, MaxStr);    LongToStr(ParamPtr, NumChannels, NumStr);    returnStr := CONCAT(LoadStr, ',', MaxStr, ',', NumStr);       {Concat strings}    ParamPtr^.ReturnValue := PasToZero(ParamPtr, ReturnStr);      {return value back to HC}    DisposePtr(Ptr(TheStatus));    {Dispose statusPtr}  end;  procedure StudioDisk (ParamPtr: XcmdPtr);    const      bufferSize = 90000;      kNoInitOps = 3;      kParamCount = 5;    var      SndErr: OSErr;      SndMemory: Ptr;      ResIdName, ParamStr: Str255;      VolLevel, Pitch: Integer;      resMem: Handle;      theid: integer;      thetype: resType;      theName: Str255;  begin    ZeroToPas(ParamPtr, ParamPtr^.params[3]^, ResIDName);        {Get 3rd param (snd Name)}    if ParamPtr^.ParamCount = kNoInitOps then      VolLevel := 255    else      begin        ZeroToPas(ParamPtr, ParamPtr^.params[4]^, ParamStr);     {Get 4th param (initial volume level)}        VolLevel := INTEGER(StrToLong(ParamPtr, ParamStr));      end;    if StringEqual(paramPtr, ResIDName, 'Cue') then      begin        passError(ParamPtr, 711);        exit(StudioDisk)      end;    SetResLoad(False);    ResMem := GetNamedResource('snd ', ResIDName);    GetResInfo(ResMem, theID, theType, theName);    if ResError <> NoErr then      begin        passError(ParamPtr, 701);        exit(StudioDisk)      end;    releaseResource(ResMem);    SetResLoad(True);    SetVol(ParamPtr, GetWantedChannel(ParamPtr, 2), VolLevel, True);    sndErr := SndStartFilePlay(GetWantedChannel(ParamPtr, 2), 0, theID, BufferSize, nil, nil, nil, true);    ZeroToPas(ParamPtr, ParamPtr^.params[5]^, ParamStr);               {Get Pitch from 5th param}    Pitch := INTEGER(StrToLong(ParamPtr, ParamStr));    if ParamPtr^.ParamCount = kParamCount then      SetRate(ParamPtr, Pitch, GetWantedChannel(ParamPtr, 2), True)    {set the initial pitch}    else      SetRate(ParamPtr, 5, GetWantedChannel(ParamPtr, 2), True);       {set the initial pitch}  end;  procedure StudioDiskStop (ParamPtr: XcmdPtr);    var      sndErr: OSErr;  begin    sndErr := sndStopFilePlay(GetWantedChannel(ParamPtr, 2), true);  end;  procedure StudioSetDisk (paramPtr: XcmdPtr);    const      kDiskVarName = 'DSSDoubleBuffer';    var      ParamStr: Str255;      ReturnHandle: Handle;  begin    ZeroToPas(ParamPtr, ParamPtr^.params[2]^, ParamStr);    if StringEqual(paramPtr, ParamStr, 'ON') then      begin        ReturnHandle := pasToZero(paramPtr, 'true');        SetGlobal(ParamPtr, kDiskVarName, ReturnHandle);      end    else if StringEqual(paramPtr, ParamStr, 'OFF') then      begin        ReturnHandle := pasToZero(paramPtr, 'false');        SetGlobal(ParamPtr, kDiskVarName, ReturnHandle);        Playthrough(False, ParamPtr);      end    else      PassError(ParamPtr, 712);  end;  function UseDB (ParamPtr: XcmdPtr): Boolean;    const      kDiskVarName = 'DSSDoubleBuffer';    var      DBHandle: Handle;      BoolStr: Str255;  begin    DBHandle := GetGlobal(ParamPtr, kDiskVarName);    ZeroToPas(ParamPtr, POINTER(DBHandle^), BoolStr);    UseDB := StrToBool(ParamPtr, BoolStr);  end;  procedure StudioPt (ParamPtr: XcmdPtr);    var      BooleanRes: Str255;  begin    if UseDB(ParamPtr) then      begin        ZeroToPas(ParamPtr, ParamPtr^.params[2]^, BooleanRes);        if StringEqual(paramPtr, BooleanRes, 'true') then          Playthrough(True, ParamPtr)        else          Playthrough(False, ParamPtr);      end    else      PassError(ParamPtr, 713);  end;  procedure StudioGetVU (ParamPtr: XcmdPtr);    var      VUadr: LongInt;      levelErr: OSErr;      Data: Ptr;      Level: Integer;      State: integer;      LevelStr: Str255;      StateStr: str255;      Return: Str255;      myInt: LongInt;  begin    VUAdr := GetVUAdr(ParamPtr);    Data := NewPtr(SizeOf(LongInt));    LevelErr := SPBGetDeviceInfo(VUAdr, siLevelMeterOnOff, Ptr(@data));    if LevelErr <> noErr then      begin        exit(StudioGetVU);      end;    Level := LoWrd(Data);    State := HiWrd(Data);    LongToStr(ParamPtr, Level, LevelStr);    LongToStr(ParamPtr, State, StateStr);    Return := CONCAT(StateStr, ',', LevelStr);    ParamPtr^.ReturnValue := PasToZero(ParamPtr, Return);    {return value back to HC}  end;  procedure StudioGetVol (ParamPtr: XcmdPtr);    var      DSSChan1, DSSChan2, BeatChan: SndChannelPtr;      VolLevel: integer;      LGetAmpCmd: sndCommand;      errors: OSErr;      VolStr: Str255;  begin    with LGetAmpCmd do      begin        Cmd := getAmpCmd;        param1 := 0;        param2 := longInt(@VolLevel);      end;    Errors := sndDoImmediate(getWantedChannel(ParamPtr, 2), lGetAmpCmd);    LongToStr(ParamPtr, VolLevel, VolStr);    ParamPtr^.ReturnValue := PasToZero(ParamPtr, VolStr);  end;{Hypercards EntryPoint Proc}{When "Get StudioMix(...)" is called from HyperCard control is sent here. Control is then sent to the proper subcommand routine}  procedure Main (ParamPtr: XCmdPtr);    var      ParamStr: Str255;  {String containing the hypercard passed param}      BeepErr: OsErr;    {any OS errors passed from BeepDisable}  begin    ZeroToPas(ParamPtr, ParamPtr^.params[1]^, ParamStr);               {get the SubCmd Param value}    if StringEqual(paramPtr, ParamStr, 'SETVOL') then                  {Cmd is "SetVol"}      StudioVol(ParamPtr);    if StringEqual(paramPtr, ParamStr, 'GETVOL') then                  {Cmd is "GetVol"}      StudioGetVol(ParamPtr);    if StudioGestalt then                                              {determine if OS can run studioMix}      begin        if StringEqual(paramPtr, ParamStr, 'PLAY') then                {Cmd is "Play"}          begin            if UseDB(paramPtr) then              StudioDisk(ParamPtr)            else              StudioPlay(ParamPtr);          end;        if StringEqual(paramPtr, ParamStr, 'STOP') then                {Cmd is "Stop"}          begin            if UseDB(paramPtr) then              StudioDiskStop(ParamPtr)            else              StudioStop(ParamPtr);          end;        if StringEqual(paramPtr, ParamStr, 'PAUSE') then               {Cmd is "Pause"}          StudioPause(ParamPtr);        if (StringEqual(paramPtr, ParamStr, 'UNPAUSE')) or (StringEqual(paramPtr, ParamStr, 'RESUME')) then          StudioResume(ParamPtr);        if StringEqual(paramPtr, ParamStr, 'SETRATE') then             {Cmd is "SetRate"}          StudioRate(ParamPtr);        if StringEqual(paramPtr, ParamStr, 'FLUSH') then               {Cmd is "Flush"}          StudioFlush(ParamPtr);        if (StringEqual(paramPtr, ParamStr, 'LOOP')) or (StringEqual(paramPtr, ParamStr, 'BEAT')) then          StudioLoop(ParamPtr);        if StringEqual(paramPtr, ParamStr, 'UNLOAD') then              {Cmd is "Unload"}          StudioUnload(ParamPtr);        if (StringEqual(paramPtr, ParamStr, 'PROGRESS')) or (StringEqual(paramPtr, ParamStr, 'ISDONE')) then          StudioDone(ParamPtr);        if (StringEqual(paramPtr, ParamStr, 'VARIATE')) then           {Cmd is "Variate"}          StudioVariate(ParamPtr);        if (StringEqual(paramPtr, ParamStr, 'CUE')) then               {Cmd is "Cue"}          StudioCue(ParamPtr);        if (StringEqual(paramPtr, ParamStr, 'DISKPLAY')) then          StudioSetDisk(ParamPtr);        if (StringEqual(paramPtr, ParamStr, 'CPULOAD')) or (StringEqual(paramPtr, ParamStr, 'CPUData')) then              {Cmd is "CPULoad"}          StudioCPULoad(ParamPtr);      end;    if StringEqual(paramPtr, ParamStr, 'GESTALTSTUDIO') then           {Cmd is "GestaltStudio"}      begin        BoolToStr(ParamPtr, StudioGestalt, ParamStr);                  {convert the response to a string}        ParamPtr^.ReturnValue := (PasToZero(ParamPtr, ParamStr));      {Pass the response back to HC}      end;    if StringEqual(paramPtr, ParamStr, 'GETDISKPLAY') then             {Cmd is "GestaltStudio"}      begin        BoolToStr(ParamPtr, UseDB(paramPtr), ParamStr);                {convert the response to a string}        ParamPtr^.ReturnValue := (PasToZero(ParamPtr, ParamStr));      {Pass the response back to HC}      end;    if StringEqual(paramPtr, ParamStr, 'OFFSET') then                  {Cmd is "Offset"}      StudioOffset(ParamPtr);    if StringEqual(paramPtr, ParamStr, 'DISABLEBEEP') then             {Cmd is "DisableBeep"}      BeepErr := SndSetSysBeepState(sysBeepDisable);    if StringEqual(paramPtr, ParamStr, 'ENABLEBEEP') then              {Cmd is "EnableBeep"}      BeepErr := SndSetSysBeepState(sysBeepEnable);    if StringEqual(paramPtr, ParamStr, 'MASTERVOL') then               {Cmd is "MasterVol"}      StudioSetMaster(ParamPtr);    if StringEqual(paramPtr, ParamStr, 'GETMASTERVOL') then            {Cmd is "GetMasterVol"}      StudioGetMaster(ParamPtr);    if StringEqual(paramPtr, ParamStr, 'PLAYTHRU') then                {Cmd is "GetMasterVol"}      StudioPT(ParamPtr);  end;    {End Main Procedure}end.      {End Unit StudioMix unit}